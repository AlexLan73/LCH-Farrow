// ═════════════════════════════════════════════════════════════════════════════
// GENERATOR GPU KERNELS
// kernels_generator.cl
// ═════════════════════════════════════════════════════════════════════════════
//
// Два OpenCL kernel-а для параллельной генерации ЛЧМ сигналов на GPU:
// 1. kernel_lfm_basic   - базовый ЛЧМ сигнал (без задержек)
// 2. kernel_lfm_delayed - ЛЧМ сигнал с дробной задержкой по лучам
//
// СТРУКТУРА ВЫХОДА (для обоих kernels):
// output[ray_id * num_samples + sample_id] = complex signal
// Это дает последовательность: [ray0_all_samples][ray1_all_samples]...[rayn_all_samples]
//
// ═════════════════════════════════════════════════════════════════════════════

// ═════════════════════════════════════════════════════════════════════
// KERNEL 1: БАЗОВЫЙ ЛЧМ СИГНАЛ (БЕЗ ЗАДЕРЖЕК)
// ═════════════════════════════════════════════════════════════════════
//
// Генерирует базовый ЛЧМ сигнал ПАРАЛЛЕЛЬНО для всех лучей.
// Сигнал идентичен для всех лучей (без фазовых сдвигов/задержек).
//
// МАТЕМАТИКА:
// Фаза: φ(t) = 2π(f_start * t + 0.5 * chirp_rate * t²)
// Сигнал: x(t) = e^(jφ(t)) = cos(φ) + j*sin(φ)
//
// ВХОДНЫЕ ПАРАМЕТРЫ:
// - f_start:        начальная частота (Гц)
// - f_stop:         конечная частота (Гц)
// - sample_rate:    частота дискретизации (12 МГц)
// - duration:       длительность сигнала (сек)
// - num_samples:    количество отсчётов на луч (1,300,000)
// - num_beams:      количество лучей (256)
//
// ПАРАЛЛЕЛИЗМ:
// Каждый поток GPU обрабатывает один отсчёт одного луча.
// Total threads = num_samples * num_beams = 1,300,000 * 256
// (все потоки работают ОДНОВРЕМЕННО)
//

__kernel void kernel_lfm_basic(
    __global float2 *output,        // Выход: [ray0_all][ray1_all]...
    float f_start,                  // Начальная частота (Гц)
    float f_stop,                   // Конечная частота (Гц)
    float sample_rate,              // Частота дискретизации (Гц)
    float duration,                 // Длительность сигнала (сек)
    uint num_samples,               // Количество отсчётов на луч
    uint num_beams                  // Количество лучей (256)
) {
    uint gid = get_global_id(0);    // Глобальный индекс потока
    
    // Проверка границ
    if (gid >= (uint)num_samples * num_beams) return;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ШАРИВАНИЕ РАБОТЫ МЕЖДУ ПОТОКАМИ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // Каждый поток обрабатывает один элемент:
    // Если у нас есть 333,200,000 потоков (256 лучей × 1,300,000 отсчётов)
    // то поток #0 → ray 0, sample 0
    //    поток #1 → ray 0, sample 1
    //    ...
    //    поток #1300000 → ray 1, sample 0
    //    поток #1300001 → ray 1, sample 1
    //    ... и так далее
    uint ray_id = gid / num_samples;       // Какой луч?
    uint sample_id = gid % num_samples;    // Какой отсчёт в этом луче?
    
    if (ray_id >= num_beams || sample_id >= num_samples) return;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // РАСЧЁТ ФАЗЫ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // Время для этого отсчёта (одинаково для всех лучей!)
    float t = (float)sample_id / sample_rate;
    
    // Скорость изменения частоты (chirp rate)
    // chirp_rate = (f_stop - f_start) / duration (Гц/сек)
    float chirp_rate = (f_stop - f_start) / duration;
    
    // Мгновенная фаза ЛЧМ сигнала (в радианах)
    // φ(t) = 2π(f_start * t + 0.5 * chirp_rate * t²)
    float phase = 2.0f * 3.14159265f * (
        f_start * t + 0.5f * chirp_rate * t * t
    );
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // КОМПЛЕКСНЫЙ СИГНАЛ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // x(t) = e^(jφ(t)) = cos(φ) + j*sin(φ)
    float real = cos(phase);
    float imag = sin(phase);
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ЗАПИСЬ В ВЫХОДНОЙ БУФЕР
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // Линейный адрес в GPU памяти:
    // output[ray_id * num_samples + sample_id]
    uint out_idx = ray_id * num_samples + sample_id;
    output[out_idx] = (float2)(real, imag);
}


// ═════════════════════════════════════════════════════════════════════
// KERNEL 2: ЛЧМ СИГНАЛ С ДРОБНОЙ ЗАДЕРЖКОЙ ПО ЛУЧАМ
// ═════════════════════════════════════════════════════════════════════
//
// Генерирует ЛЧМ сигналы с РАЗНЫМИ задержками для КАЖДОГО луча.
// Задержки берутся из массива m_delay[] (градусы → время).
//
// ВХОДНЫЕ ПАРАМЕТРЫ:
// - m_delay[]:      массив {beam_id, delay_degrees} - задержки по лучам
// - delay_degrees:  задержка в градусах (0.5, 1.5, 6.0, ...)
// - остальные параметры - те же, что в kernel_lfm_basic
//
// ПРЕОБРАЗОВАНИЕ ЗАДЕРЖКИ:
// 1. delay_degrees (градусы) → delay_rad (радианы)
// 2. delay_rad → delay_time (секунды) через длину волны
// 3. delay_time → delay_samples (отсчёты)
// 4. Применить временную задержку к ЛЧМ сигналу
//
// ПАРАЛЛЕЛИЗМ:
// Каждый поток GPU обрабатывает один отсчёт одного луча.
// ВСЕ потоки работают ОДНОВРЕМЕННО с РАЗНЫМИ задержками!
//

__kernel void kernel_lfm_delayed(
    __global float2 *output,                // Выход: [ray0_delayed][ray1_delayed]...
    __constant DelayParam *m_delay,         // Входные задержки {beam_id, delay_deg}
    float f_start,                          // Начальная частота (Гц)
    float f_stop,                           // Конечная частота (Гц)
    float sample_rate,                      // Частота дискретизации (Гц)
    float duration,                         // Длительность сигнала (сек)
    float speed_of_light,                   // Скорость света (3.0e8 м/с)
    uint num_samples,                       // Количество отсчётов
    uint num_beams,                         // Количество лучей (256)
    uint num_delays                         // Количество параметров задержки
) {
    uint gid = get_global_id(0);
    
    // Проверка границ
    if (gid >= (uint)num_samples * num_beams) return;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // РАСПРЕДЕЛЕНИЕ РАБОТЫ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    uint ray_id = gid / num_samples;
    uint sample_id = gid % num_samples;
    
    if (ray_id >= num_beams || sample_id >= num_samples) return;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ПОЛУЧИТЬ ЗАДЕРЖКУ ДЛЯ ЭТОГО ЛУЧА
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // m_delay[ray_id].delay_degrees содержит задержку в градусах
    float delay_degrees = m_delay[ray_id].delay_degrees;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ПРЕОБРАЗОВАНИЕ ЗАДЕРЖКИ: ГРАДУСЫ → ВРЕМЯ → ОТСЧЁТЫ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // 1. Конвертировать градусы в радианы
    float delay_rad = delay_degrees * 3.14159265f / 180.0f;
    
    // 2. Центральная частота сигнала
    float f_center = (f_start + f_stop) / 2.0f;
    
    // 3. Длина волны на центральной частоте
    float wavelength = speed_of_light / f_center;
    
    // 4. Время задержки (в секундах)
    // delay_time = delay_rad * wavelength / speed_of_light
    float delay_time = delay_rad * wavelength / speed_of_light;
    
    // 5. Количество отсчётов задержки
    float delay_samples = delay_time * sample_rate;
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ПРИМЕНИТЬ ЗАДЕРЖКУ К ЛЧМ СИГНАЛУ
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // Эффективный индекс с задержкой
    int delayed_sample_int = (int)sample_id - (int)delay_samples;
    
    float real, imag;
    
    if (delayed_sample_int < 0) {
        // До начала сигнала - заполняем нулями
        real = 0.0f;
        imag = 0.0f;
    } else {
        // Время для задержанного отсчёта
        float t = (float)delayed_sample_int / sample_rate;
        
        // Скорость изменения частоты
        float chirp_rate = (f_stop - f_start) / duration;
        
        // Мгновенная фаза
        float phase = 2.0f * 3.14159265f * (
            f_start * t + 0.5f * chirp_rate * t * t
        );
        
        // Комплексный сигнал
        real = cos(phase);
        imag = sin(phase);
    }
    
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    // ЗАПИСЬ В ВЫХОДНОЙ БУФЕР
    // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    uint out_idx = ray_id * num_samples + sample_id;
    output[out_idx] = (float2)(real, imag);
}


// ═════════════════════════════════════════════════════════════════════
// ВСПОМОГАТЕЛЬНАЯ СТРУКТУРА
// ═════════════════════════════════════════════════════════════════════

typedef struct {
    uint beam_index;           // Номер луча (0-255)
    float delay_degrees;       // Задержка в градусах
} DelayParam;
